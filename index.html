<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Block Blast Helper</title>
<style>
body { font-family: sans-serif; text-align: center; }
#board {
    display: grid;
    grid-template-columns: repeat(8, 40px);
    grid-template-rows: repeat(8, 40px);
    gap: 2px; margin: 20px auto; width: max-content;
}
.cell {
    width: 40px; height: 40px;
    background-color: #eee;
    border: 1px solid #ccc;
}
.active { background-color: #4caf50; }
.ghost { background-color: rgba(0, 150, 255, 0.4); cursor: pointer; }
#blocks {
    display: flex; justify-content: center; gap: 20px; margin-top: 20px;
}
.block { display: grid; gap: 2px; cursor: pointer; }
.block-cell { width: 20px; height: 20px; background-color: #777; }
</style>
</head>
<body>
<h1>Block Blast Helper</h1>
<div id="board"></div>
<div id="blocks"></div>

<script>
const boardSize = 8;
const board = Array.from({ length: boardSize }, () => Array(boardSize).fill(0));
const blockShapes = [
    [[1,1,1]],               // 横3
    [[1],[1],[1]],           // 縦3
    [[1,1],[1,1]],           // 2x2
    [[1,1,1,1]],              // 横4
    [[1],[1],[1],[1]],       // 縦4
    [[1,1,1],[0,1,0]],        // T字
    [[1,0],[1,0],[1,1]],      // L字
    [[0,1],[0,1],[1,1]],      // 逆L字
    [[1,1,0],[0,1,1]],        // S字
    [[0,1,1],[1,1,0]],        // Z字
    [[1,1,1],[1,0,0]],        // 角付きL
    [[1,1,1],[0,0,1]]         // 角付き逆L
];

// const blockShapes = [
//     [[1,1,1]], [[1],[1],[1]], [[1,1],[1,1]],
//     [[1,1,1,1]], [[1],[1],[1],[1]]
// ];

let selectedBlock = null;
const boardEl = document.getElementById('board');
const blocksEl = document.getElementById('blocks');

// 盤面描画
function renderBoard(ghosts=[]) {
    boardEl.innerHTML = '';
    for (let y=0; y<boardSize; y++) {
        for (let x=0; x<boardSize; x++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            if (board[y][x]===1) cell.classList.add('active');
            if (ghosts.some(g => g.x===x && g.y===y)) {
                cell.classList.add('ghost');
                const root = ghosts.find(g => g.x===x && g.y===y);
                cell.addEventListener('click', ()=>placeBlock(selectedBlock, root.rootX, root.rootY));
            }
            boardEl.appendChild(cell);
        }
    }
}

// ブロック表示
function renderBlocks() {
    blocksEl.innerHTML = '';
    blockShapes.forEach(shape => {
        const block = document.createElement('div');
        block.className = 'block';
        block.style.gridTemplateColumns = `repeat(${shape[0].length}, 20px)`;
        block.style.gridTemplateRows = `repeat(${shape.length}, 20px)`;
        shape.forEach(row => row.forEach(val => {
            const cell = document.createElement('div');
            if (val===1) cell.className = 'block-cell';
            block.appendChild(cell);
        }));
        block.addEventListener('click', () => {
            selectedBlock = shape;
            showSafeHints(shape);
        });
        blocksEl.appendChild(block);
    });
}

// 置けるかどうか
function canPlace(block, x, y, state=board) {
    for (let i=0; i<block.length; i++) {
        for (let j=0; j<block[i].length; j++) {
            if (block[i][j]===1) {
                const bx = x+j, by = y+i;
                if (bx<0||bx>=8||by<0||by>=8||state[by][bx]===1) return false;
            }
        }
    }
    return true;
}

// 仮想配置
function simulatePlace(block, x, y, state) {
    const newBoard = state.map(row => [...row]);
    for (let i=0; i<block.length; i++) {
        for (let j=0; j<block[i].length; j++) {
            if (block[i][j]===1) newBoard[y+i][x+j]=1;
        }
    }
    return newBoard;
}

// まだ置ける手があるか
function hasAnyMove(state) {
    for (const shape of blockShapes) {
        for (let y=0; y<=8-shape.length; y++) {
            for (let x=0; x<=8-shape[0].length; x++) {
                if (canPlace(shape, x, y, state)) return true;
            }
        }
    }
    return false;
}

// 安全な手かどうか
function isSafeMove(block, x, y, state) {
    const after = simulatePlace(block, x, y, state);
    return hasAnyMove(after);
}

function evaluateBoard(state) {
    let score = 0;

    // 空きマスの数（多い方が良い）
    let emptyCount = 0;
    for (let y=0; y<8; y++) {
        for (let x=0; x<8; x++) {
            if (state[y][x] === 0) emptyCount++;
        }
    }
    score += emptyCount;

    // 消せる行や列の数（多い方が良い）
    for (let y=0; y<8; y++) {
        if (state[y].every(c => c===1)) score += 20;
    }
    for (let x=0; x<8; x++) {
        let full = true;
        for (let y=0; y<8; y++) if (state[y][x]===0) full = false;
        if (full) score += 20;
    }

    return score;
}

function findBestPlacements(shape) {
    let best = [];
    let bestScore = -1;

    for (let y=0; y<=8-shape.length; y++) {
        for (let x=0; x<=8-shape[0].length; x++) {
            if (canPlace(shape, x, y, board)) {
                const newState = simulatePlace(shape, x, y, board);
                const score = countNextMoves(newState);
                if (score > bestScore) {
                    bestScore = score;
                    best = [{x,y}];
                } else if (score === bestScore) {
                    best.push({x,y});
                }
            }
        }
    }
    return best;
}

function countNextMoves(state) {
    let count = 0;
    for (const shape of blockShapes) {
        for (let y=0; y<=8-shape.length; y++) {
            for (let x=0; x<=8-shape[0].length; x++) {
                if (canPlace(shape, x, y, state)) count++;
            }
        }
    }
    return count;
}

function findBestPlacements(shape) {
    let best = [];
    let bestScore = -1;

    for (let y=0; y<=8-shape.length; y++) {
        for (let x=0; x<=8-shape[0].length; x++) {
            if (canPlace(shape, x, y, board)) {
                const newState = simulatePlace(shape, x, y, board);
                const score = countNextMoves(newState);
                if (score > bestScore) {
                    bestScore = score;
                    best = [{x,y}];
                } else if (score === bestScore) {
                    best.push({x,y});
                }
            }
        }
    }
    return best;
}

function showSafeHints(shape) {
    const bestPositions = findBestPlacements(shape);
    const ghosts = [];

    bestPositions.forEach(pos => {
        shape.forEach((row,dy)=>row.forEach((val,dx)=>{
            if (val===1) ghosts.push({x:pos.x+dx,y:pos.y+dy,rootX:pos.x,rootY:pos.y});
        }));
    });

    renderBoard(ghosts);
}

// // 安全な位置だけゴースト表示
// function showSafeHints(shape) {
//     let bestScore = -Infinity;
//     let bestPos = null;

//     for (let y=0; y<=8-shape.length; y++) {
//         for (let x=0; x<=8-shape[0].length; x++) {
//             if (canPlace(shape,x,y,board)) {
//                 const newState = simulatePlace(shape,x,y,board);
//                 if (hasAnyMove(newState)) {
//                     const score = evaluateBoard(newState);
//                     if (score > bestScore) {
//                         bestScore = score;
//                         bestPos = {x,y};
//                     }
//                 }
//             }
//         }
//     }

//     // 最良位置をゴースト表示
//     const ghosts = [];
//     if (bestPos) {
//         shape.forEach((row,dy)=>row.forEach((val,dx)=>{
//             if (val===1) ghosts.push({x:bestPos.x+dx,y:bestPos.y+dy,rootX:bestPos.x,rootY:bestPos.y});
//         }));
//     }

//     renderBoard(ghosts);
// }


// 実際に置く
function placeBlock(block, x, y) {
    if (!canPlace(block,x,y,board)) return;
    for (let i=0; i<block.length; i++) {
        for (let j=0; j<block[i].length; j++) {
            if (block[i][j]===1) board[y+i][x+j]=1;
        }
    }
    clearLines(); // ← 追加
    renderBoard();
}
function clearLines() {
    // 横ラインを確認
    for (let y = 0; y < boardSize; y++) {
        if (board[y].every(cell => cell === 1)) {
            board[y].fill(0);
        }
    }
    // 縦ラインを確認
    for (let x = 0; x < boardSize; x++) {
        let full = true;
        for (let y = 0; y < boardSize; y++) {
            if (board[y][x] === 0) {
                full = false;
                break;
            }
        }
        if (full) {
            for (let y = 0; y < boardSize; y++) {
                board[y][x] = 0;
            }
        }
    }
}
// コードの順序
// 1. board, blockShapes 定義
// 2. canPlace, simulatePlace, hasAnyMove
// 3. countNextMoves ← ここを追加
// 4. findBestPlacements
// 5. showSafeHints
// 6. renderBoard, renderBlocks
// 7. placeBlock, clearLines
renderBoard();
renderBlocks();
</script>
</html>
